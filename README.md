# PropelTech technical assessment
This is a barebones Symfony API Platform implementation with one business class

## Development process

### Step 1: Install Symfony API Platform
- `mkdir ~/propeltech`
- Download API Platform from https://github.com/api-platform/api-platform/releases/latest (v4.1.0, tar.gz) and copy into `~/propeltech`
- `cd ~/propeltech`
- `tar -xvzf api-platform-4.1.0.tar.gz`
- `mv api-platform-4.1.0/{.,}* .`
- `rmdir api-platform-4.1.0`
- `rm api-platform-4.1.0.tar.gz`
- `sudo docker compose build --no-cache`
- `sudo docker compose up -d`
- **OUTCOME**
  - A standard Symfony API Platform is available at https://localhost
  - From https://api-platform.com/docs/symfony/: "You'll need to add a security exception in your browser to accept the self-signed TLS certificate that has been generated for this container when installing the framework."

### Step 2: Configure API Platform to our tastes
- Disable HTTPS: The generation of a signed SSL certificate is out of scope.
- Move from using annotations to using XML for platform configuration: I prefer a separation of code and configuration.
- Move from using underscores in endpoints to using dashes (personal preference).
- Configure API Platform to use standard PUT, so that an entity can be partially updated (personal preference).
- Remove the default migration and Greetings entity.
- **OUTCOME**
  - A reconfigured Symfony API Platform is available at http://localhost

### Step 3: Create the business model in Skipper
- `Person` business class
- Generate entity: `sudo docker compose exec php php bin/console make:entity --regenerate`
- Generate Postgres schema: although the task does not ask for database persistence, I thought it worthwhile to show how API Platform helps here:
  - `sudo docker compose exec php php bin/console doctrine:migrations:diff`
  - `sudo docker compose exec php php bin/console doctrine:migrations:migrate`
- **OUTCOME**
  - Business model design/entity and Postgres database schema are in-place, but not yet visible via the API.

### Step 4: Enable API endpoints for the Person entity
- Using API Platform configuration, define collection GET, collection POST, item GET, item PUT and item DELETE using seralisation groups.
- Add validation for the Person entity, asssuming that all fields are required and that email is a valid email address.
- As we are not depending on the Person id to be generated by the database, assign a UUID to a new `Person`.
- Acceptance tests added
- **OUTCOME**
  - A full API now exists, with persistence to the database:
    - Collection GET: `GET http://localhost/persons`
    - Collection POST: `POST http://localhost/persons`
    - Item GET: `GET http://localhost/persons/:id`
    - Item PUT: `PUT http://localhost/persons/:id`
    - Item DELETE: `DELETE http://localhost/persons/:id`
  - One of the tests fails, but with a 500 server error rather than a 422 response

### Step 5: `Person` phone propery was too short at 10 characters
- Updated `phone` to 11 characters, migration automatically generated
- Updated test to test for 11 characters
- Fixed the failing 500 test by adding more validation, so that a 422 response is received.

### Step 6: So far so good, but to this point we've been using Postgres for storage
- The requirement is for data to be stored in a JSON flat file.
- With API Platform, that's easy to resolve via state providers/processors and a different type of repository which reads from a JSON text file
- The tests continue to pass, and there is a new unit test for the part of the new storage mechanism
